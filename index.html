<html>
<head>
<script>
const State = {
	Clickable: 0,
	Animating: 1,
	Dragging:  2,
	DragCatchUpAnimation: 3
}

function sin(degrees){
	return Math.sin(2 * Math.PI * degrees / 360);
}

function cos(degrees){
	return Math.cos(2 * Math.PI * degrees / 360);
}

const flowerRadius = 24;

class Game{
	constructor(sprites, audio){
		this.sprites = sprites;
		this.audio = audio;
		this.left = 148;
		this.top = 95;
		this.horizontalSpacing = 55;
		this.verticalSpacing = 48;
		
		this.flowersAround = [];
		this.flowersAround[ 4] = [ 0, 1, 5, 9, 8, 3];
		this.flowersAround[ 5] = [ 1, 2, 6,10, 9, 4];
		this.flowersAround[ 8] = [ 3, 4, 9,13,12, 7];
		this.flowersAround[ 9] = [ 4, 5,10,14,13, 8];
		this.flowersAround[10] = [ 5, 6,11,15,14, 9];
		this.flowersAround[13] = [ 8, 9,14,17,16,12];
		this.flowersAround[14] = [ 9,10,15,18,17,13];
		
		this.indexToCol = [0,1,2,0,1,2,3,0,1,2,3,4,0,1,2,3,0,1,2];
		this.indexToRow = [0,0,0,1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,4];
		
		this.levels = [
		{arrangement: [2,2,2,2,2,2,2,2,2,2,2,2,2,2,6,2,2,2,2],  goal: [2,2,2,2,2,2,2,2,2,6,2,2,2,2,2,2,2,2,2]},
		{arrangement: [5,5,5,0,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5],  goal: [5,5,5,5,5,5,5,5,0,5,0,5,5,5,5,5,5,5,5]},
		{arrangement: [5,4,5,5,0,4,5,5,5,5,5,5,5,5,5,5,5,5,5],  goal: [5,5,5,5,4,4,5,5,5,0,5,5,5,5,5,5,5,5,5]},			
		{arrangement: [8,6,8,8,8,6,6,8,8,6,8,8,8,8,8,8,8,8,8],  goal: [8,8,8,8,6,6,8,8,6,8,6,8,8,8,8,8,8,8,8]},		
		{arrangement: [3,3,7,7,3,3,3,3,3,7,3,7,3,3,3,3,3,7,3],  goal: [3,7,3,3,3,3,3,7,3,7,3,7,3,3,3,3,3,7,3]},
		{arrangement: [2,2,2,9,2,9,9,2,2,9,2,2,2,9,9,2,2,2,2],  goal: [2,2,2,2,9,9,2,2,9,2,9,2,2,9,9,2,2,2,2]},		
		{arrangement: [5,5,4,4,4,10,5,5,5,4,5,5,5,5,5,4,4,5,5], goal: [5,4,5,5,5,5,5,4,4,10,4,4,5,5,5,5,5,4,5]},
		{arrangement: [4,8,8,6,6,5,6,8,8,5,8,4,4,6,3,4,8,8,8],  goal: [8,4,8,8,6,6,8,4,5,3,5,4,8,6,6,8,8,4,8]}];
		
		this.levelId     = 0;
		this.arrangement = this.levels[this.levelId].arrangement;
		this.goal        = this.levels[this.levelId].goal;
		
		
		this.state = State.Clickable;
		this.animationTime = 200;
		
		this.chosenFlowerToRotateAround = -1;
	}
	
	mousedown(x, y, button){
		if (this.state != State.Clickable)
			return;
			
		this.clickedFlower = this.getClickedFlower(x, y, flowerRadius);
		
		if (this.clickedFlower && this.isRotateable(this.clickedFlower.index)){
			this.state = State.Animating;
			this.directionIsLeft = button == 0;
			this.animationStartTime = -1;
			
			this.audio.rotate.play();
		} else {
			this.audio.noRotate.play();
		}
	}
	
	touchstart(x, y){
		this.mdx= x;
		this.mdy= y;
		this.touchedFlowers = [];
		let touchedFlowerStart = this.getClickedFlower(this.mdx, this.mdy, flowerRadius);
		if (touchedFlowerStart){
			this.touchedFlowers.push(touchedFlowerStart);
		}
	}
	
	touchmove(x2, y2){
		if (this.state == State.Animating)
			return;
		
		if (this.chosenFlowerToRotateAround != -1){						
			let c = this.indexToCol[this.chosenFlowerToRotateAround];
			let r = this.indexToRow[this.chosenFlowerToRotateAround];
			
			let axisX = this.left + this.horizontalSpacing * c - (2-Math.abs(r-2)) * this.horizontalSpacing / 2;
			let axisY = this.top + this.verticalSpacing * r;
						
			let angleNow = Math.atan2(y2 - axisY, x2-axisX);
						
			this.deltaAngle = (angleNow - this.angleDown) * 180 / Math.PI;			
					
			return;
		}
		
		
		
		let touchedFlowerMove  = this.getClickedFlower(x2, y2, flowerRadius);
		if (touchedFlowerMove){
			if (!this.touchedFlowers.some((element)=>element.index == touchedFlowerMove.index)){
				this.touchedFlowers.push(touchedFlowerMove);
			}
		}
			
		if (this.touchedFlowers.length >= 1){
			
			let candidateCoreFlowers = [4,5,8,9,10,13,14];
			
			for (let touchedFlower of this.touchedFlowers){
				candidateCoreFlowers = candidateCoreFlowers.filter( (candidate) => this.isNeighbour(candidate, touchedFlower.index));
				if (candidateCoreFlowers.length <= 1) 
					break;
			}
			
			if (candidateCoreFlowers.length == 0){
				this.touchedFlowers.pop();
			}

			
			if (candidateCoreFlowers.length == 1){
				let match = candidateCoreFlowers[0];
		
				this.clickedFlower =  {index: match, column: this.indexToCol[match], row: this.indexToRow[match]};
				this.state = State.Dragging;
				this.deltaAngle = 0;				
				
				this.chosenFlowerToRotateAround = match;
				
				let c = this.indexToCol[this.chosenFlowerToRotateAround];
				let r = this.indexToRow[this.chosenFlowerToRotateAround];
				
				let axisX = this.left + this.horizontalSpacing * c - (2-Math.abs(r-2)) * this.horizontalSpacing / 2;
				let axisY = this.top + this.verticalSpacing * r;
								
				this.angleDown = Math.atan2(y2 - axisY, x2 - axisX);
				//this.angleDownReal = Math.atan2(this.mdy - axisY, this.mdx - axisX);  
				
				this.audio.rotate.play();				
			}
		}
	}
	
	touchend(x, y){	
		this.state = State.Clickable;
	
		if (this.chosenFlowerToRotateAround == -1){
			return;
		}
		
				
		let turns = Math.round(this.deltaAngle / 60);	
		
		while (turns > 0){
			this.rotateRight(this.chosenFlowerToRotateAround);
			--turns;
		}
		
		while (turns < 0){
			this.rotateLeft(this.chosenFlowerToRotateAround);
			++turns;
		}
		
		this.chosenFlowerToRotateAround = -1;
		
		this.checkForWin();
	}
	
	rotateLeft(i){
		let positionsToRotate = this.flowersAround[i];
		let first = this.arrangement[positionsToRotate[0]];
		for (let j = 0; j < 6; ++j){
			this.arrangement[positionsToRotate[j]] = this.arrangement[positionsToRotate[j+1]];
		}
		this.arrangement[positionsToRotate[5]] = first;
	}
	
	rotateRight(i){
		let positionsToRotate = this.flowersAround[i];
		let last = this.arrangement[positionsToRotate[5]];
		for (let j = 5; j >= 0; --j){
			this.arrangement[positionsToRotate[j]] = this.arrangement[positionsToRotate[j-1]];
		}
		this.arrangement[positionsToRotate[0]] = last;
	}
		
	draw(ctx, time){
		ctx.drawImage(this.sprites[11], 0, 0); //background
		if (this.state == State.Animating){
			if (this.animationStartTime == -1){
				this.animationStartTime = time;
			}
			var animationTimeElapsed = time - this.animationStartTime;			
			
			if (animationTimeElapsed > this.animationTime){
				animationTimeElapsed = this.animationTime;
			}
			let offsetAngle = 60 * animationTimeElapsed / this.animationTime * (this.directionIsLeft? -1:1);
			
			this.drawGridSkippingRing(ctx, this.left, this.top, this.horizontalSpacing, this.verticalSpacing, this.clickedFlower.index, 1.0);
			this.drawRing(ctx, this.left, this.top, this.horizontalSpacing, this.verticalSpacing, this.clickedFlower.column, this.clickedFlower.row, this.clickedFlower.index, offsetAngle);
			
			if (animationTimeElapsed >= this.animationTime){
				if (this.directionIsLeft)
					this.rotateLeft(this.clickedFlower.index);
				else
					this.rotateRight(this.clickedFlower.index);
					
				this.state = State.Clickable;
				
				this.checkForWin();
			}
		} else if (this.state == State.Dragging){
			this.drawGridSkippingRing(ctx, this.left, this.top, this.horizontalSpacing, this.verticalSpacing, this.clickedFlower.index, 1.0);
			this.drawRing(ctx, this.left, this.top, this.horizontalSpacing, this.verticalSpacing, this.clickedFlower.column, this.clickedFlower.row, this.clickedFlower.index, this.deltaAngle);
		}else{
			this.drawGrid(ctx, this.left, this.top, this.horizontalSpacing, this.verticalSpacing, 1.0, this.arrangement);		
		}
		this.drawGrid(ctx, 455, 64, 29, 23, 0.5, this.goal);//minimap
	}
	
	isRotateable(i){
		return this.flowersAround[i] != null;
	}
	
	isNeighbour(i,j){
		return this.isRotateable(i) && this.flowersAround[i].indexOf(j) != -1;
	}
	
	
	drawGrid(ctx, x, y, dx, dy, scale, data){
		var i = 0;
		for (let r = 0; r < 5; ++r){
			for (let c = 0; c < 5 - Math.abs(r-2); ++c){
				this.drawSprite(ctx, x + dx * c - (2-Math.abs(r-2)) * dx / 2, y + dy * r, data[i], scale);
				++i;
			}			
		}
	}	
	
	drawGridSkippingRing(ctx, x, y, dx, dy, skipIndex, scale){
		var i = 0;
		for (let r = 0; r < 5; ++r){
			for (let c = 0; c < 5 - Math.abs(r-2); ++c){
				if (!this.isNeighbour(skipIndex, i)){
					this.drawSprite(ctx, x + dx * c - (2-Math.abs(r-2)) * dx / 2, y + dy * r, this.arrangement[i], scale);
				}
				++i;
			}
		}
		
	}
	
	drawRing(ctx, x, y, dx, dy, c, r, index, offsetAngle){
		let angle = 240;
				
		let cx = x + dx * c - (2-Math.abs(r-2)) * dx / 2;
		let cy = y + dy * r;
		
		for (let i = 0; i < 6; ++i){
			let ox = cx + dx           * cos(angle + offsetAngle);
			let oy = cy + (dy/sin(60)) * sin(angle + offsetAngle);
			
			this.drawSprite(ctx, ox, oy, this.arrangement[this.flowersAround[index][i]], 1.0)
			
			angle += 60;
		}
	}
	
	drawSprite(ctx, x, y, id, scale){
		ctx.drawImage(this.sprites[id], x - this.sprites[id].width / 2, y - this.sprites[id].height / 2, this.sprites[id].width * scale, this.sprites[id].height * scale);
	}
	
	getClickedFlower(x2, y2, radius){
		var i = 0;
		for (let r = 0; r < 5; ++r){
			for (let c = 0; c < 5 - Math.abs(r-2); ++c){
				let x1 = this.left + this.horizontalSpacing * c - (2-Math.abs(r-2)) * this.horizontalSpacing / 2;
				let y1 = this.top + this.verticalSpacing * r;
				
				let distanceSquared = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)
				
				if (distanceSquared < radius * radius){
					return {index: i, column: c, row: r};
				}
				++i;
			}
		}
		return null;
	}
	
	checkForWin(){
		if (this.arrangement.every((value, index) => value === this.goal[index])){
			this.audio.win.play();
			
			++this.levelId;
			this.arrangement = this.levels[this.levelId].arrangement;
			this.goal        = this.levels[this.levelId].goal;
		}
	}
}

function loadSprites(path, numSprites, onLoadCompletion, onLoadProgress){
	var sprites = [];
	var numLoaded = 0;
	var numError = 0;
	
	for (var i=1; i <= numSprites; ++i){
		var img = new Image();		
		img.src = path + i + ".png";
		img.onload = function () {						
			numLoaded++;
			if (numLoaded + numError == numSprites){
				onLoadCompletion(numLoaded, numError);
			}else if (onLoadProgress != null){		
				onLoadProgress(numLoaded, numError);				
			}
		};
		img.onerror = function () {						
			numError++;
			if (numLoaded + numError == numSprites){
				onLoadCompletion();
			}else if (onLoadProgress != null){
				onLoadProgress(numLoaded, numError);
			}
		};
		sprites.push(img);
	}
	return sprites;
}

function start(){	
	var canvas = document.getElementById("MyCanvas");		
	var ctx = canvas.getContext("2d");
	
	
    canvas.addEventListener('touchstart', function(e){
        var touchobj = e.changedTouches[0];
		var rect = canvas.getBoundingClientRect();
        
		x = touchobj.clientX - rect.left;
		y = touchobj.clientY - rect.top;
		game.touchstart(x, y);
		
        e.preventDefault();
    }, false);
	
	canvas.addEventListener('touchmove', function(e){
        var touchobj = e.changedTouches[0];
		var rect = canvas.getBoundingClientRect();
        
		x = touchobj.clientX - rect.left;
		y = touchobj.clientY - rect.top;
		game.touchmove(x, y);
		
        e.preventDefault();
    }, false);
	
	canvas.addEventListener('touchend', function(e){
        var touchobj = e.changedTouches[0];
		var rect = canvas.getBoundingClientRect();
        
		x = touchobj.clientX - rect.left;
		y = touchobj.clientY - rect.top;
		game.touchend(x, y);
		
        e.preventDefault();
    }, false);
	
	
	canvas.addEventListener('mousedown', function(evt){
		var rect = canvas.getBoundingClientRect();
		x = evt.clientX - rect.left;
		y = evt.clientY - rect.top;
		game.touchstart(x, y);		
	});
	
	canvas.addEventListener('mousemove', function(evt){
		if (evt.buttons == 0) return;
		var rect = canvas.getBoundingClientRect();
		x = evt.clientX - rect.left;
		y = evt.clientY - rect.top;
		game.touchmove(x, y);		
	});
	
	canvas.addEventListener('mouseup', function(evt){		
		var rect = canvas.getBoundingClientRect();
		x = evt.clientX - rect.left;
		y = evt.clientY - rect.top;
		game.touchend(x, y);		
	});
	
	/*
	canvas.addEventListener('mousedown', function(evt){
		var rect = canvas.getBoundingClientRect();
		x = evt.clientX - rect.left;
		y = evt.clientY - rect.top;
		game.mousedown(x, y, evt.button);		
	});*/
	
	canvas.addEventListener('contextmenu', function(ev) {
		ev.preventDefault();    
		return false;
	}, false);
	
		
	setInterval(()=>window.requestAnimationFrame((time)=>game.draw(ctx, time)), 16);
}

var sprites = loadSprites("Sprites\\", 14, start);
var audio = {
	rotate: new Audio('Waves/Rotate.wav'),
	noRotate: new Audio('Waves/NoRotate.wav'),
	win: new Audio('Waves/NextLevel.wav')
};
var game = new Game(sprites, audio);

</script>
</head>
<body>
<canvas id="MyCanvas" width="628" height="400" style="border:1px solid #000000; background-color:#008000;"></canvas>
</body>
</html>
